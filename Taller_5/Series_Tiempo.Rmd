---
title: "Taller 5 - Series de tiempo"
author:
  - name: "Jhon Fernando Tascon Velasco"
  - name: "Lino Alexander Sinisterra"
  - name: "Juan Sebastian Chacón"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(readxl)
library(dplyr)
library(tidyverse)
library(plotly)
library(ggcorrplot)
library(ggplot2)
library(reshape2)
library(ResourceSelection)
library(knitr)
library(kableExtra)
library(fpp2)
library(tseries)
library(gridExtra)
library(xts)
```

## **0. Información general**

Los datos contienen la información de los precios en bolsa de la energía en Colombia (COP/kWh).
Asumimos que somos compradores de energía, por lo que el pronosticar los precios de la energía es una herramienta esratégica fundamental para la estabilidad financiera, estabilidad operativa y planificación al largo plazo. Además, el mercado de energía en Colombia es volátil, por lo ntao, el poder anticiparnos al comportamiento de los precios nos ayudarán a tomar decisiones de cuánto y cuándo comprar y buscar de alternativas que nos permitan mitigar el riesgo operativo o financiero.

Pregunta objetivo: ¿cuáles serán los precios de la energía para los siguientes 7 días?

Complementar con:
•	Presenta una breve descripción del concepto de “Serie de tiempo” y del modelo ARIMA.
•	Explica la importancia y utilidad de los modelos ARIMA en la predicción de series temporales.

## **1. Análisis exploratorio**

```{r carga_datos, echo=FALSE}
df = read.csv2("Precio_Energia.csv", sep=",", header=TRUE, dec=".")
df = df %>%
  mutate(
    Fecha_Hora = as.POSIXct(FechaHora, format="%Y-%m-%d %H:%M:%S")
  ) %>%
  arrange(Fecha_Hora) %>%
  dplyr::select(Fecha_Hora, Valor)
head(df)
```

### **1.1. Revisión de datos faltantes**
```{r nulos, echo=FALSE}
# Revisar si hay faltantes
nulos = colSums(is.na(df))

kable(nulos, caption = "Datos faltantes") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

### **1.2. Revisar comportamiento del precio por día**
```{r comportamiento_diario, fig.width=10, fig.height=3, echo=FALSE, warning=FALSE}
df$Fecha = as.Date(df$Fecha_Hora)

# Crear boxplot por día
ggplot(df, aes(x = Fecha, y = Valor, fill = factor(Fecha))) +
  geom_boxplot(outlier.shape = NA) +
  labs(title = "Distribución diaria de precios horarios de energía",
       x = "Fecha",
       y = "Precio (COP/kWh)"
  ) +
  scale_x_date(
    date_labels = "%Y-%b-%d", date_breaks = "1 day",
    limits = as.Date(c("2025-08-01", "2025-09-30"))
  ) +
  coord_cartesian(ylim = c(0, 1000)) +
  theme_minimal() +
  guides(fill = "none") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10))
```

Vemos que la distribución diaria de los precios de la energía no son simétricos, por lo tanto se agregarán los datos utilizando dos medidas: mediana y media. La mediana nos ayudará para visualizar tendencias y estacionalidades en la serie de tiempo. La media nos ayudará a identificar diías en los que el precio fue más volátil.

### **1.3. Gráfico de la serie de tiempo**
```{r grafico, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
df_clean <- df %>%
  group_by(Fecha) %>%
  summarise(
    Precio_Mediana = median(Valor),
    Precio_Promedio = mean(Valor)
  )

# Estadísticas descriptivas
desc = summary(df_clean)
kable(desc, caption = "Etadísticas descriptivas") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# Graficando ambas líneas en un solo gráfico
df_clean %>%
  # Pivotamos los datos para que ggplot pueda asignar un color a cada métrica
  pivot_longer(
    cols = c("Precio_Mediana", "Precio_Promedio"), 
    names_to = "Metrica", 
    values_to = "Precio"
  ) %>%
  ggplot(aes(x = Fecha, y = Precio, group = Metrica, color = Metrica)) +
  geom_line(linewidth = 1) +
  labs(
    title = "Precio Diario de la Energía (Mediana vs. Promedio)",
    x = "Fecha",
    y = "Precio de Bolsa (COP/kWh)",
    color = "Métrica" # Título de la leyenda
  ) +
  scale_color_manual(values = c("Precio_Mediana" = "dodgerblue", "Precio_Promedio" = "firebrick")) +
  theme_minimal() +
  theme(legend.position = "top")
```

Complementar con:
•	Estadísticas descriptivas de la serie (media, desviación estándar, tendencia, estacionalidad, etc.).

Con base en el gráfico anterior, no hay mucha diferencia entre la mediana y la media en la serie de tiempo a analziar. Por lo tanto, para este caso, se escogerá el precio promedio como la serie a trabajar.

## **2. Modelo de series de tiempo**
```{r split, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
# Convertir los datos a serie de tiempo
df_clean = xts(df_clean$Precio_Promedio, order.by = as.Date(df_clean$Fecha))

train = window(df_clean, end = "2024-03-31") # ventana de entrenamiento
test = window(df_clean, start = "2024-04-01") # ventana de prueba

autoplot(train)
ggAcf(train, lag.max=50, main="Función de Autocorrelación (ACF) de los precio de energía (COP/kWh)")
```

Con base en el gráfico ACF, se evidencia que la serie de tiempo no es estacionariam ya que las autocorrelaciones son altas y persistentes a lo largos de los retrasos. A continuación, se identificará cuál sería el retraso "óptimo".

```{r retrasos, echo=FALSE, warning=FALSE}
p_value = 0.05
best_lag = 0
for (i in c(1:60)) {
  adf_test = adf.test(train, k=i)
  print(adf_test)
  p = adf_test$p.value
  if (p > p_value) {
    best_lag = i
  }
}

cat(paste("El lag 'óptimo' es:", best_lag))
cat("\nA continuación, se presentan los resultados del Dickey-Fuller Test:")
adf.test(train, k=best_lag)
```

```{r diferenciar, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
diff_precios = diff(train, 7) %>% na.omit()
autoplot(diff_precios)
grid.arrange(ggAcf(diff_precios),
             ggPacf(diff_precios),
             nrow=2,
             ncol=1
)

adf.test(diff_precios)
```

Con base en el ACF y PACF, tenemos que p podría ser 2 y q podría ser 1. A continuación presentamos los análisis. La diferenciación es de primer orden.

```{r modelo1, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
p = 2
q = 1
d = 1

#cat(paste("Modelo Arima 1: p =", 1))


```

```{r modelo_auto, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
auto.arima(train)

```

## **3. Conclusiones**
asdasdfasdf


