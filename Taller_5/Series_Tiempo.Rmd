---
title: "Taller 5 - Series de tiempo"
author:
  - name: "Jhon Fernando Tascon Velasco"
  - name: "Lino Alexander Sinisterra"
  - name: "Juan Sebastian Chacón"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(readxl)
library(dplyr)
library(tidyverse)
library(plotly)
library(ggcorrplot)
library(ggplot2)
library(reshape2)
library(ResourceSelection)
library(knitr)
library(kableExtra)
library(fpp2)
library(tseries)
library(gridExtra)
library(xts)
library(forecast)
```

## **0. Información general**

Los datos contienen la información de los precios en bolsa de la energía en Colombia (COP/kWh).
Asumimos que somos compradores de energía, por lo que el pronosticar los precios de la energía es una herramienta esratégica fundamental para la estabilidad financiera, estabilidad operativa y planificación al largo plazo. Además, el mercado de energía en Colombia es volátil, por lo ntao, el poder anticiparnos al comportamiento de los precios nos ayudarán a tomar decisiones de cuánto y cuándo comprar y buscar de alternativas que nos permitan mitigar el riesgo operativo o financiero.

Pregunta objetivo: ¿cuáles serán los precios de la energía para los siguientes 7 días?

Complementar con:
•	Presenta una breve descripción del concepto de “Serie de tiempo” y del modelo ARIMA.
•	Explica la importancia y utilidad de los modelos ARIMA en la predicción de series temporales.

## **1. Análisis exploratorio**

```{r carga_datos, echo=FALSE}
df = read.csv2("Precio_Energia.csv", sep=",", header=TRUE, dec=".")
df = df %>%
  mutate(
    Fecha_Hora = as.POSIXct(FechaHora, format="%Y-%m-%d %H:%M:%S")
  ) %>%
  arrange(Fecha_Hora) %>%
  dplyr::select(Fecha_Hora, Valor)
head(df)
```

### **1.1. Revisión de datos faltantes**
```{r nulos, echo=FALSE}
# Revisar si hay faltantes
nulos = colSums(is.na(df))

kable(nulos, caption = "Datos faltantes") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

### **1.2. Revisar comportamiento del precio por día**
```{r comportamiento_diario, fig.width=10, fig.height=3, echo=FALSE, warning=FALSE}
df$Fecha = as.Date(df$Fecha_Hora)

# Crear boxplot por día
ggplot(df, aes(x = Fecha, y = Valor, fill = factor(Fecha))) +
  geom_boxplot(outlier.shape = NA) +
  labs(title = "Distribución diaria de precios horarios de energía",
       x = "Fecha",
       y = "Precio (COP/kWh)"
  ) +
  scale_x_date(
    date_labels = "%Y-%b-%d", date_breaks = "1 day",
    limits = as.Date(c("2025-08-01", "2025-09-30"))
  ) +
  coord_cartesian(ylim = c(0, 1000)) +
  theme_minimal() +
  guides(fill = "none") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 10))
```

Vemos que la distribución diaria de los precios de la energía no son simétricos, por lo tanto se agregarán los datos utilizando dos medidas: mediana y media. La mediana nos ayudará para visualizar tendencias y estacionalidades en la serie de tiempo. La media nos ayudará a identificar diías en los que el precio fue más volátil.

### **1.3. Gráfico de la serie de tiempo**
```{r grafico, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
df_clean <- df %>%
  group_by(Fecha) %>%
  summarise(
    Precio_Mediana = median(Valor),
    Precio_Promedio = mean(Valor)
  )

# Estadísticas descriptivas
desc = summary(df_clean)
kable(desc, caption = "Etadísticas descriptivas") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))

# Graficando ambas líneas en un solo gráfico
df_clean %>%
  # Pivotamos los datos para que ggplot pueda asignar un color a cada métrica
  pivot_longer(
    cols = c("Precio_Mediana", "Precio_Promedio"), 
    names_to = "Metrica", 
    values_to = "Precio"
  ) %>%
  ggplot(aes(x = Fecha, y = Precio, group = Metrica, color = Metrica)) +
  geom_line(linewidth = 1) +
  labs(
    title = "Precio Diario de la Energía (Mediana vs. Promedio)",
    x = "Fecha",
    y = "Precio de Bolsa (COP/kWh)",
    color = "Métrica" # Título de la leyenda
  ) +
  scale_color_manual(values = c("Precio_Mediana" = "dodgerblue", "Precio_Promedio" = "firebrick")) +
  theme_minimal() +
  theme(legend.position = "top")
```

Complementar con:
•	Estadísticas descriptivas de la serie (media, desviación estándar, tendencia, estacionalidad, etc.).

Con base en el gráfico anterior, no hay mucha diferencia entre la mediana y la media en la serie de tiempo a analziar. Por lo tanto, para este caso, se escogerá el precio promedio como la serie a trabajar.

## **2. Modelo de series de tiempo**
```{r split, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
# Convertir los datos a serie de tiempo
df_clean = xts(df_clean$Precio_Promedio, order.by = as.Date(df_clean$Fecha))

train = window(df_clean, end = "2025-03-31") # ventana de entrenamiento
test = window(df_clean, start = "2025-04-01") # ventana de prueba

autoplot(train)
ggAcf(train, lag.max=50, main="Función de Autocorrelación (ACF) de los precio de energía (COP/kWh)")
```

Con base en el gráfico ACF, se evidencia que la serie de tiempo no es estacionariam ya que las autocorrelaciones son altas y persistentes a lo largos de los retrasos. A continuación, se identificará cuál sería el retraso "óptimo".

```{r retrasos, echo=FALSE, warning=FALSE}
p_value = 0.04
best_lag = 0
for (i in c(1:60)) {
  adf_test = adf.test(train, k=i)
  print(adf_test)
}
```

Explicar qué podría ssignificar, y por qué estos valores para la serie de tiempo de precios de energía

### **2.1. Modelamiento**
```{r diferenciar_1, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
diff_precios = diff(train) %>% na.omit()
autoplot(diff_precios, main="Diferenciación de primer orden")
grid.arrange(ggAcf(diff_precios),
             ggPacf(diff_precios),
             nrow=2,
             ncol=1
)

adf.test(diff_precios)
```

Con base en el ACF y PACF, tenemos que p podría ser de orden 2 y q podría ser orden 2, además de una diferenciación de primer orden. Sin embargo, se logra evidenciar ciertos patrones semanales (cada 7 días o cada 28 días). Por ende, se realiza aplicará una diferenciación estacional (7 días y 28 días) y luego una de primer orden.

```{r diferenciar_2, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
diff_precios = diff(diff(train, 7), 1) %>% na.omit()
autoplot(diff_precios, main="Diferenciación estacional (7 días) y luego diferenciación del primer orden")
grid.arrange(ggAcf(diff_precios),
             ggPacf(diff_precios),
             nrow=2,
             ncol=1
)

adf.test(diff_precios)
```

Con base en este gráfico, aparentemente el orden de p es 2 y el orden de q es de 2, con una diferenciación de primer orden. A continuación, se analizará la diferenciación estacional de 28 días y luego diferenciación de primer orden.

```{r diferenciar_3, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
diff_precios = diff(diff(train, 28), 1) %>% na.omit()
autoplot(diff_precios, main="Diferenciación estacional (28 días) y luego diferenciación del primer orden")
grid.arrange(ggAcf(diff_precios),
             ggPacf(diff_precios),
             nrow=2,
             ncol=1
)

adf.test(diff_precios)
```

Con base en este gráfico, aparentemente el orden de p sigue siendo 2 y el orden de q también es de 2, con una diferenciación de primer orden. Con base en los resultados anteriores, se aplciarán los siguientes modelos:

- Auto-ARIMA
- Modelo 1: ARIMA(2, 1, 2)
- Modelo 2: ARIMA(1, 1, 2)

```{r modelo_auto, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
modelo_auto = auto.arima(train)
```

```{r modelo1, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
p1 = 2
d1 = 1
q1 = 2
modelo1 = Arima(train, order = c(p1,d1,q1))
```

```{r modelo2, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
p2 = 1
d2 = 1
q2 = 2
modelo2 = Arima(train, order = c(p2,d2,q2))
```

#### **Resumen de los resultados ARIMA**
```{r resumen, echo=FALSE, warning=FALSE}
resumen_df = data.frame(
  Modelo = c(
    "Auto-ARIMA",
    "Modelo 1",
    "Modelo 2"
  ),
  Orden_p = c(
    modelo_auto$arma[1],
    p1,
    p2
  ),
  Orden_d = c(
    modelo_auto$arma[6],
    d1,
    d2
  ),
  Orden_q = c(
    modelo_auto$arma[2],
    q1,
    q2
  ),
  AIC = c(
    modelo_auto$aic,
    modelo1$aic,
    modelo2$aic
  ),
  AICc = c(
    modelo_auto$aicc,
    modelo1$aicc,
    modelo2$aicc
  ),
  BIC = c(
    modelo_auto$bic,
    modelo1$bic,
    modelo2$bic
  )
)

kable(resumen_df, caption = "Resumen modelos Arima") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Interpretar

#### **Modelo SARIMA**
```{r parameteros, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
diff_precios = diff(train) %>% na.omit()
autoplot(diff_precios, main="Diferenciación de primer orden")
grid.arrange(ggAcf(diff_precios),
             ggPacf(diff_precios),
             nrow=2,
             ncol=1
)

adf.test(diff_precios)
```

Para el cálculo de P y Q, las compnentes estacionales de SARIMA, se evidencia que hay picos significativos en el lag 7 en PACF y en los lags 7 y 28 en el ACF. Lo anterior, nos sugiere. que P es de orden 1 y Q es de orden 1.

```{r sarima1, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
p_sarima1 = 1
d_sarima1 = 1
q_sarima1 = 1
P_sarima1 = 1
D_sarima1 = 1
Q_sarima1 = 1

modelo_sarima1 = Arima(train, order = c(p_sarima1,d_sarima1,q_sarima1),
                       seasonal = list(order = c(P_sarima1,D_sarima1,Q_sarima1), period = 7))
modelo_sarima1
```

```{r sarima2, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
p_sarima2 = 2
d_sarima2 = 1
q_sarima2 = 2
P_sarima2 = 1
D_sarima2 = 1
Q_sarima2 = 1

modelo_sarima2 = Arima(train, order = c(p_sarima2,d_sarima2,q_sarima2),
                       seasonal = list(order = c(P_sarima2,D_sarima2,Q_sarima2), period = 7))
modelo_sarima2
```

Interpretar

#### **Resumen de los resultados totales**
```{r resumen2, echo=FALSE, warning=FALSE}
resumen_df = data.frame(
  Modelo = c(
    "Auto-ARIMA",
    "Modelo 1",
    "Modelo 2",
    "SARIMA 1",
    "SARIMA 2"
  ),
  Orden_p = c(
    modelo_auto$arma[1],
    p1,
    p2,
    p_sarima1,
    p_sarima2
  ),
  Orden_d = c(
    modelo_auto$arma[6],
    d1,
    d2,
    d_sarima1,
    d_sarima2
  ),
  Orden_q = c(
    modelo_auto$arma[2],
    q1,
    q2,
    q_sarima1,
    q_sarima2
  ),
  Orden_P = c(
    0,
    0,
    0,
    P_sarima1,
    P_sarima2
  ),
  Orden_D = c(
    0,
    0,
    0,
    D_sarima1,
    D_sarima2
  ),
  Orden_Q = c(
    0,
    0,
    0,
    Q_sarima1,
    Q_sarima2
  ),
  AIC = c(
    modelo_auto$aic,
    modelo1$aic,
    modelo2$aic,
    modelo_sarima1$aic,
    modelo_sarima2$aic
  ),
  AICc = c(
    modelo_auto$aicc,
    modelo1$aicc,
    modelo2$aicc,
    modelo_sarima1$aicc,
    modelo_sarima2$aicc
  ),
  BIC = c(
    modelo_auto$bic,
    modelo1$bic,
    modelo2$bic,
    modelo_sarima1$bic,
    modelo_sarima2$bic
  )
)

kable(resumen_df, caption = "Resumen modelos ARIMA") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Interpretar

#### **Evaluación de residuos**
```{r evaluacion_residuos, echo=FALSE, warning=FALSE}
checkresiduals(modelo_sarima2)
```

Interpretar

#### **Evaluación de resultados**
```{r eval_resultados, echo=FALSE, warning=FALSE}
h = length(test)  # horizonte de pronóstico
pronostico = forecast(modelo_sarima2, h = h)

accuracy(pronostico, test)
```

#### Generación de pronósticos
```{r pronosticos, fig.width=12, fig.height=5, echo=FALSE, warning=FALSE}
#Pronostico
#Gráfico
modelo_sarima2 %>% 
  forecast(h=7) %>%  # (Realizo 7 pronósticos)
  autoplot(include=100)   # Gráfico los últimos 100 valores + pronóstico (se puede cambiar el 80)
```

Interpretar

## **3. Conclusiones**
asdasdfasdf


